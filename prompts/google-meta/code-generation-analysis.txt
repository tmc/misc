backend: googleai
messages:
- role: system
  text: You are an expert in analyzing the trajectory of code-generating LLMs. Examine
    the history of code generation requests, focusing on the correctness, efficiency,
    and readability of the generated code. Identify prompting strategies that lead
    to robust and maintainable code.
- role: human
  text: Start by listing the criteria you will use to assess the quality of code generated
    by an LLM.
- role: ai
  text: |
    Okay, here are the criteria I will use to assess the quality of code generated by a Large Language Model (LLM), focusing on correctness, efficiency, and readability. These criteria are crucial for determining the practical utility and long-term maintainability of the generated code.

    **I. Correctness:** This is the most fundamental aspect. Does the code do what it's supposed to do?

    *   **Functionality:**
        *   **Fulfillment of Requirements:** Does the code accurately implement the specified functionality described in the prompt or request? This includes handling all stated inputs, outputs, and edge cases.
        *   **Absence of Bugs:** Does the code execute without errors or unexpected behavior under various valid inputs?
        *   **Robustness:** Does the code gracefully handle invalid or unexpected inputs, preventing crashes or undefined behavior? Does it include appropriate error handling and input validation?
        *   **Security:** Does the code avoid common security vulnerabilities (e.g., SQL injection, cross-site scripting, buffer overflows)? This is especially important for code that interacts with external systems or user inputs.
        *   **Testing:** While not directly assessed, the ease with which the code can be tested is a strong indicator of its correctness. Well-structured code is easier to test thoroughly.

    **II. Efficiency:** How well does the code utilize resources?

    *   **Time Complexity:** Does the code execute within an acceptable timeframe, especially for large inputs? Does it use algorithms with appropriate time complexity for the given task?
    *   **Space Complexity:** Does the code use memory efficiently? Does it avoid unnecessary memory allocation or data duplication?
    *   **Resource Utilization:**  Does the code minimize the use of other resources like network bandwidth, disk I/O, or external API calls, where applicable?
    *   **Algorithmic Choice:** Does the code employ the most suitable algorithm for the problem at hand, considering both time and space efficiency?

    **III. Readability:** How easy is the code to understand and maintain?

    *   **Clarity and Simplicity:** Is the code written in a clear and straightforward manner, avoiding unnecessary complexity? Is the logic easy to follow?
    *   **Consistency:** Does the code adhere to consistent coding style and conventions (e.g., naming, indentation, formatting)?
    *   **Comments and Documentation:** Are there sufficient comments explaining the purpose and logic of complex sections of code? Is there appropriate documentation (e.g., docstrings) explaining the usage of functions and classes?
    *   **Modularity:** Is the code broken down into well-defined functions or modules that perform specific tasks? This improves organization and reusability.
    *   **Naming Conventions:** Are variables, functions, and classes named descriptively, reflecting their purpose and role in the code?
    *   **Code Structure:** Is the code well-organized, with a logical flow and structure that is easy to navigate?
    *   **Adherence to Language Idioms:** Does the code leverage the idiomatic features and best practices of the programming language it's written in?

    **IV. Maintainability:** This is closely related to readability but also considers the long-term aspects of code evolution.

    *   **Extensibility:** Is it easy to add new features or modify existing functionality without introducing bugs or requiring extensive code refactoring?
    *   **Reusability:** Are parts of the code designed in a way that they can be reused in other parts of the project or in other projects?
    *   **Testability:** Is the code written in a way that makes it easy to write unit tests and integration tests?
    *   **Refactorability:** Is it easy to refactor the code to improve its design or performance without changing its external behavior?

    **V. Contextual Awareness (Advanced Criterion):**

    *   **Problem Domain Understanding:** Does the generated code demonstrate an understanding of the specific problem domain and its constraints?
    *   **Integration with Existing Code:** If the generated code is meant to be integrated into an existing codebase, does it adhere to the style, conventions, and architecture of that codebase?
    *   **Optimization for Specific Environments:** Does the code take into account the specific environment in which it will be deployed (e.g., serverless, embedded systems, web browser)?

    By applying these criteria, I can provide a comprehensive evaluation of the code generated by LLMs and identify trends in their strengths and weaknesses over time. This will help us understand how to best leverage these powerful tools for software development.
model: gemini-exp-1206
