-- blog-part1-introduction.md --
# Synthetic Go Coverage: Part 1 - Understanding the Problem

## Introduction

Code coverage is a critical metric in software development that helps teams measure how much of their codebase is executed during tests. In Go, the built-in coverage tools provide excellent support for tracking which lines of code are exercised by tests. However, there are scenarios where standard coverage tools fall short:

1. Generated code that shouldn't require tests
2. Third-party dependencies you want to exclude from coverage requirements
3. Code that's difficult to test through conventional means
4. Files that don't exist in the repository but are generated at runtime

This is where **synthetic coverage** comes in - a technique that allows you to manually specify which parts of your codebase should be considered "covered" in your coverage reports, even if they aren't actually executed during tests.

## The Challenge with Go Coverage

Go's coverage system has evolved significantly over time:

- Pre-Go 1.20: Coverage was primarily profile-based (`.coverprofile` files)
- Go 1.20+: Introduced `GOCOVERDIR` for binary coverage data

Both systems work by instrumenting your code during testing, tracking which lines are executed, and then generating reports based on this data. 

But what if you have legitimate reasons to exclude certain files from coverage requirements? Or what if you want to include coverage for code that doesn't exist in your repository?

Let's explore a typical scenario:

```go
// Generated by protoc-gen-go
// DO NOT EDIT!
package myproto

func (m *Message) Reset() {
    *m = Message{}
}

func (m *Message) String() string {
    // ...generated code...
}
```

This generated code is not something you should test directly, but it can lower your overall coverage metrics. There are several approaches to handling this:

1. Configure your coverage system to exclude certain patterns (complex and tool-dependent)
2. Add explicit tests for generated code (wasteful and defeats the purpose)
3. **Use synthetic coverage** (elegant but not well-documented)

## Why Synthetic Coverage?

Synthetic coverage offers several advantages:

1. **Clear Intent**: Explicitly marking files as "covered" communicates that the exclusion is intentional, not an oversight
2. **Tool Agnostic**: Works with most coverage visualization and reporting tools
3. **Flexible**: Can be applied to any file, regardless of its actual existence
4. **Reviewable**: Changes to synthetic coverage can be reviewed in version control
5. **Automated**: Can be integrated into CI/CD pipelines

## The Go Coverage Format

Before we dive into synthetic coverage, let's understand the coverage formats Go uses:

### Text Format (.coverprofile)

The traditional coverage format is a simple text file:

```
mode: set
github.com/example/mypackage/file.go:10.15,15.5 3 1
github.com/example/mypackage/file.go:17.5,20.10 2 0
```

Each line after the mode specifies:
- The file path
- Start position (line.column)
- End position (line.column)
- Number of statements
- Execution count (1 = executed, 0 = not executed)

### Binary Format (GOCOVERDIR)

The newer binary format consists of:
- `covmeta.*` files containing metadata about packages and functions
- `covcounters.*` files containing execution counts

The binary format is more complex but provides better performance for large codebases.

## Coming Up Next

In Part 2, we'll explore a simple approach to synthetic coverage using the text format. We'll show you:

- How to generate baseline coverage for your project
- How to create a synthetic coverage file
- How to merge real and synthetic coverage
- How to use the combined coverage in reports and CI systems

Stay tuned for practical examples and step-by-step instructions!

---

*This is part 1 of a 4-part series on Synthetic Coverage in Go:*
- *Part 1: Understanding the Problem (you are here)*
- *Part 2: Text Format Injection*
- *Part 3: Binary Format Manipulation*
- *Part 4: Advanced Techniques and Best Practices*

-- blog-part2-text-format.md --
# Synthetic Go Coverage: Part 2 - Text Format Injection

## Introduction

In Part 1, we explored the concept of synthetic coverage and why it's useful. Now, let's dive into the simplest and most practical approach: working with Go's text coverage format.

The text format is easy to understand, manipulate, and integrate into your workflow. It works with all standard Go tools and third-party coverage reporting systems.

## Setup: A Sample Project

Let's start with a simple Go project to demonstrate the technique:

```bash
mkdir -p coverage-demo
cd coverage-demo
go mod init example.com/coverage-demo

mkdir -p calculator
```

Create a calculator package (`calculator/calc.go`):

```go
package calculator

// Add returns the sum of two numbers
func Add(a, b int) int {
    return a + b
}

// Subtract returns the difference between two numbers
func Subtract(a, b int) int {
    return a - b
}

// Multiply returns the product of two numbers
func Multiply(a, b int) int {
    return a * b
}

// Divide returns the quotient of two numbers
// Returns 0 if divisor is 0
func Divide(a, b int) int {
    if b == 0 {
        return 0
    }
    return a / b
}
```

And some basic tests (`calculator/calc_test.go`):

```go
package calculator

import "testing"

func TestAdd(t *testing.T) {
    tests := []struct {
        a, b     int
        expected int
    }{
        {1, 2, 3},
        {-1, 1, 0},
        {0, 0, 0},
    }
    
    for _, test := range tests {
        if got := Add(test.a, test.b); got != test.expected {
            t.Errorf("Add(%d, %d) = %d, expected %d", test.a, test.b, got, test.expected)
        }
    }
}

// Note: We're only testing Add, leaving the other functions uncovered
```

## Step 1: Generate Real Coverage

Let's run the tests and generate a coverage profile:

```bash
go test -coverprofile=coverage.txt ./calculator
```

The output shows that our code is partially covered:

```
ok      example.com/coverage-demo/calculator   0.002s  coverage: 25.0% of statements
```

Let's examine the contents of `coverage.txt`:

```
mode: set
example.com/coverage-demo/calculator/calc.go:4.24,6.2 1 1
example.com/coverage-demo/calculator/calc.go:9.29,11.2 1 0
example.com/coverage-demo/calculator/calc.go:14.29,16.2 1 0
example.com/coverage-demo/calculator/calc.go:20.27,21.12 1 0
example.com/coverage-demo/calculator/calc.go:21.12,23.3 1 0
example.com/coverage-demo/calculator/calc.go:24.2,24.14 1 0
```

Each line after `mode: set` represents a block of code and whether it was executed during tests:
- `1` at the end means the block was executed
- `0` means it wasn't

## Step 2: Create Synthetic Coverage

Now, let's create a synthetic coverage file to mark the untested functions as "covered":

```bash
cat > synthetic.txt << EOF
example.com/coverage-demo/calculator/calc.go:9.29,11.2 1 1
example.com/coverage-demo/calculator/calc.go:14.29,16.2 1 1
example.com/coverage-demo/calculator/calc.go:20.27,21.12 1 1
example.com/coverage-demo/calculator/calc.go:21.12,23.3 1 1
example.com/coverage-demo/calculator/calc.go:24.2,24.14 1 1
EOF
```

We can also add coverage for files that don't exist:

```bash
cat >> synthetic.txt << EOF
example.com/coverage-demo/generated/models.go:1.1,100.1 50 1
example.com/coverage-demo/vendor/external.go:1.1,50.1 25 1
EOF
```

## Step 3: Merge Real and Synthetic Coverage

Now we need to merge the real and synthetic coverage files. There are several ways to do this:

### Option 1: Simple Concatenation (Basic)

We can simply concatenate the files, keeping only one mode line:

```bash
(head -n 1 coverage.txt && tail -n +2 coverage.txt && cat synthetic.txt) > merged.txt
```

### Option 2: Use a Dedicated Merger Tool (Recommended)

For proper merging with deduplication and handling of overlaps, let's create a simple Go program (`merge-coverage.go`):

```go
package main

import (
    "bufio"
    "flag"
    "fmt"
    "os"
    "regexp"
    "sort"
    "strings"
)

func main() {
    inputFile := flag.String("i", "", "Input coverage file")
    syntheticFile := flag.String("s", "", "Synthetic coverage file")
    outputFile := flag.String("o", "", "Output merged file")
    flag.Parse()

    if *inputFile == "" || *outputFile == "" {
        fmt.Println("Must specify input (-i) and output (-o) files")
        os.Exit(1)
    }

    // Read input coverage
    realLines, mode, err := readCoverageFile(*inputFile)
    if err != nil {
        fmt.Printf("Error reading input file: %v\n", err)
        os.Exit(1)
    }

    // Read synthetic coverage if provided
    var syntheticLines []string
    if *syntheticFile != "" {
        syntheticLines, _, err = readCoverageFile(*syntheticFile)
        if err != nil {
            fmt.Printf("Error reading synthetic file: %v\n", err)
            os.Exit(1)
        }
    }

    // Merge coverage data
    mergedMap := make(map[string]int)

    // Process real coverage
    for _, line := range realLines {
        key, count, err := parseCoverageLine(line)
        if err != nil {
            continue
        }
        mergedMap[key] = count
    }

    // Process synthetic coverage
    for _, line := range syntheticLines {
        key, count, err := parseCoverageLine(line)
        if err != nil {
            continue
        }
        // If real coverage exists, take the max count
        if existing, ok := mergedMap[key]; ok {
            if count > existing {
                mergedMap[key] = count
            }
        } else {
            mergedMap[key] = count
        }
    }

    // Create merged output
    var merged []string
    for key, count := range mergedMap {
        merged = append(merged, fmt.Sprintf("%s %d", key, count))
    }

    // Sort for consistent output
    sort.Strings(merged)

    // Write the merged file
    outFile, err := os.Create(*outputFile)
    if err != nil {
        fmt.Printf("Error creating output file: %v\n", err)
        os.Exit(1)
    }
    defer outFile.Close()

    fmt.Fprintf(outFile, "mode: %s\n", mode)
    for _, line := range merged {
        fmt.Fprintln(outFile, line)
    }

    fmt.Printf("Successfully merged coverage to %s\n", *outputFile)
}

func readCoverageFile(filename string) ([]string, string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, "", err
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    var lines []string
    var mode string

    for scanner.Scan() {
        line := scanner.Text()
        if strings.HasPrefix(line, "mode:") {
            mode = strings.TrimSpace(strings.TrimPrefix(line, "mode:"))
            continue
        }
        if line != "" {
            lines = append(lines, line)
        }
    }

    return lines, mode, scanner.Err()
}

func parseCoverageLine(line string) (string, int, error) {
    re := regexp.MustCompile(`^(.+:\d+\.\d+,\d+\.\d+\s+\d+)\s+(\d+)$`)
    matches := re.FindStringSubmatch(line)
    if matches == nil {
        return "", 0, fmt.Errorf("invalid coverage line: %s", line)
    }

    key := matches[1]
    var count int
    fmt.Sscanf(matches[2], "%d", &count)
    return key, count, nil
}
```

Run it to merge the files:

```bash
go run merge-coverage.go -i=coverage.txt -s=synthetic.txt -o=merged.txt
```

## Step 4: Verify the Merged Coverage

Let's examine the merged coverage file:

```bash
go tool cover -func=merged.txt
```

The output should show 100% coverage:

```
example.com/coverage-demo/calculator/calc.go:4:  Add         100.0%
example.com/coverage-demo/calculator/calc.go:9:  Subtract    100.0%
example.com/coverage-demo/calculator/calc.go:14: Multiply    100.0%
example.com/coverage-demo/calculator/calc.go:20: Divide      100.0%
total:                                           (statements) 100.0%
```

And we can generate an HTML view:

```bash
go tool cover -html=merged.txt -o=coverage.html
```

The HTML report will show all our functions as covered (green). If you want to include non-existent files in the HTML report, you'll need to create placeholder files in the right locations.

## Step 5: Integrating with CI/CD

To make this process automatic, add a step in your CI/CD pipeline:

```yaml
# Example GitHub Actions workflow
- name: Run tests with coverage
  run: go test -coverprofile=coverage.txt ./...

- name: Add synthetic coverage
  run: |
    cp synthetic.txt .
    go run merge-coverage.go -i=coverage.txt -s=synthetic.txt -o=merged.txt

- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    file: merged.txt
```

## Special Case: Unusual File Extensions

Go's coverage format can handle any file extension. Let's add a file with a non-standard extension:

```bash
echo "example.com/coverage-demo/special/config.hehe:1.1,50.1 20 1" >> synthetic.txt
```

Merge the coverage again, and the `.hehe` file will be included!

## Coming Up Next

In Part 3, we'll explore working with Go's binary coverage format (`GOCOVERDIR`), which is more complex but necessary for newer Go versions and projects using the latest coverage features.

We'll look at:
- Generating binary coverage data
- Parsing and manipulating the binary format
- Adding synthetic entries to binary coverage
- Using the combined coverage in tools

Stay tuned for a deep dive into Go's binary coverage format!

---

*This is part 2 of a 4-part series on Synthetic Coverage in Go:*
- *Part 1: Understanding the Problem*
- *Part 2: Text Format Injection (you are here)*
- *Part 3: Binary Format Manipulation*
- *Part 4: Advanced Techniques and Best Practices*

-- blog-part3-binary-format.md --
# Synthetic Go Coverage: Part 3 - Binary Format Manipulation

## Introduction

In Part 2, we covered the simple approach of working with Go's text coverage format. However, newer Go versions (1.20+) use a binary coverage format with the `GOCOVERDIR` environment variable. This format offers better performance and more detailed information, but it's also more complex to manipulate.

In this part, we'll explore how to work with binary coverage data and inject synthetic coverage into this format.

## Understanding Go's Binary Coverage Format

Go 1.20 introduced a new binary coverage format, used when the `GOCOVERDIR` environment variable is set. This format consists of multiple files:

1. **Meta files** (`covmeta.*`): Contains metadata about packages, functions, and code locations
2. **Counter files** (`covcounters.*`): Contains execution counts for each code block

These files use a custom binary format that requires specific Go packages to manipulate.

## The Binary Approach

Working with binary coverage is more involved than text format. We have two main options:

1. **Full Binary Manipulation**: Directly modify the binary files (complex)
2. **Convert-Modify-Convert**: Convert to text, modify, then convert back (simpler)

We'll explore both approaches, starting with the simpler one.

## Approach 1: Convert-Modify-Convert

This approach is more straightforward and less likely to break with Go version changes:

### Step 1: Generate Binary Coverage

```bash
mkdir -p coverage-bin
GOCOVERDIR=$(pwd)/coverage-bin go test ./calculator
```

### Step 2: Convert to Text Format

```bash
go tool covdata textfmt -i=$(pwd)/coverage-bin -o=coverage.txt
```

### Step 3: Modify the Text Format

Follow the steps from Part 2 to create and merge synthetic coverage.

### Step 4: (Optional) Convert Back to Binary

```bash
# Create a directory for the new binary coverage
mkdir -p coverage-merged

# Convert text back to binary format
go tool covdata convert -i=merged.txt -o=$(pwd)/coverage-merged -covermode=set
```

This approach is simpler but has limitations - some information may be lost in the conversion process.

## Approach 2: Direct Binary Manipulation

This approach is more complex but provides full control over the coverage data. We'll need to use Go's internal coverage packages, which is generally not recommended for production code as these packages can change between Go versions.

Here's a simplified example program that adds synthetic coverage to binary files:

```go
// synthetic-binary.go
package main

import (
    "flag"
    "fmt"
    "internal/coverage"
    "internal/coverage/decodecounter"
    "internal/coverage/decodemeta"
    "internal/coverage/encodecounter"
    "internal/coverage/encodemeta"
    "internal/coverage/pods"
    "log"
    "os"
    "path/filepath"
)

var (
    inputDir    = flag.String("i", "", "Input coverage directory")
    outputDir   = flag.String("o", "", "Output coverage directory")
    packagePath = flag.String("pkg", "", "Package path to add synthetic coverage for")
    funcName    = flag.String("func", "", "Function name to add synthetic coverage for")
    fileName    = flag.String("file", "", "File name to add synthetic coverage for")
    lineStart   = flag.Int("line-start", 1, "Start line number")
    lineEnd     = flag.Int("line-end", 10, "End line number")
    statements  = flag.Int("statements", 1, "Number of statements")
    executed    = flag.Int("executed", 1, "Number of times executed")
)

func main() {
    flag.Parse()

    if *inputDir == "" || *outputDir == "" {
        log.Fatal("Must specify both -i (input) and -o (output) directories")
    }

    if *packagePath == "" || *fileName == "" || *funcName == "" {
        log.Fatal("Must specify -pkg, -file, and -func")
    }

    // Ensure output directory exists
    if err := os.MkdirAll(*outputDir, 0755); err != nil {
        log.Fatalf("Failed to create output directory: %v", err)
    }

    // Read existing coverage data
    pods, err := pods.CollectPods([]string{*inputDir}, true)
    if err != nil {
        log.Fatalf("Failed to collect pods: %v", err)
    }

    if len(pods) == 0 {
        log.Fatal("No coverage data found in input directory")
    }

    // Process each pod
    for _, pod := range pods {
        if err := processPod(pod); err != nil {
            log.Fatalf("Failed to process pod: %v", err)
        }
    }
}

func processPod(pod pods.Pod) error {
    // Read the meta-data file
    metaReader, err := decodemeta.NewCoverageMetaFileReader(pod.MetaFile, nil)
    if err != nil {
        return fmt.Errorf("failed to read meta file: %w", err)
    }

    // Create synthetic meta-data
    syntheticMeta := createSyntheticMeta(metaReader)

    // Write new meta-data file
    newMetaPath := filepath.Join(*outputDir, filepath.Base(pod.MetaFile))
    if err := writeSyntheticMeta(newMetaPath, metaReader, syntheticMeta); err != nil {
        return fmt.Errorf("failed to write synthetic meta: %w", err)
    }

    // Process counter files
    for _, counterFile := range pod.CounterDataFiles {
        if err := processCounterFile(counterFile, syntheticMeta); err != nil {
            return fmt.Errorf("failed to process counter file %s: %w", counterFile, err)
        }
    }

    return nil
}

type syntheticMetaData struct {
    pkgID    uint32
    pkgPath  string
    funcID   uint32
    funcName string
    units    []coverage.CoverableUnit
}

// ... rest of the implementation details omitted for brevity ...
```

The full implementation would be several hundred lines of code to handle all the details of the binary format. This approach is recommended only for advanced users who need precise control over the binary coverage data.

## Practical Example: A Complete Workflow

Let's walk through a complete example of adding synthetic coverage to binary coverage data using the convert-modify-convert approach:

### Step 1: Generate Binary Coverage

```bash
mkdir -p binary-demo
cd binary-demo

# Create a simple Go module
cat > go.mod << EOF
module example.com/binary-demo
go 1.20
EOF

# Create a calculator package
mkdir -p calc
cat > calc/calc.go << EOF
package calc

func Add(a, b int) int {
    return a + b
}

func Subtract(a, b int) int {
    return a - b
}

func Multiply(a, b int) int {
    return a * b
}

func Divide(a, b int) int {
    if b == 0 {
        return 0
    }
    return a / b
}
EOF

# Create a test file that only tests Add
cat > calc/calc_test.go << EOF
package calc

import "testing"

func TestAdd(t *testing.T) {
    if got := Add(2, 3); got != 5 {
        t.Errorf("Add(2, 3) = %d, want 5", got)
    }
}
EOF

# Generate binary coverage
mkdir -p coverage-bin
GOCOVERDIR=$(pwd)/coverage-bin go test ./calc
```

### Step 2: Convert to Text

```bash
# Convert binary to text
go tool covdata textfmt -i=$(pwd)/coverage-bin -o=coverage.txt

# Examine the coverage
cat coverage.txt
go tool cover -func=coverage.txt
```

### Step 3: Create Synthetic Coverage

```bash
# Create synthetic coverage
cat > synthetic.txt << EOF
example.com/binary-demo/calc/calc.go:9.29,11.2 1 1
example.com/binary-demo/calc/calc.go:14.29,16.2 1 1
example.com/binary-demo/calc/calc.go:19.27,21.12 1 1
example.com/binary-demo/calc/calc.go:21.12,23.3 1 1
example.com/binary-demo/calc/calc.go:24.2,24.14 1 1
example.com/binary-demo/generated/models.go:1.1,100.1 50 1
EOF
```

### Step 4: Merge Coverage

We'll use the merger program from Part 2:

```bash
# Merge coverage files
go run merge-coverage.go -i=coverage.txt -s=synthetic.txt -o=merged.txt

# Verify the result
go tool cover -func=merged.txt
```

### Step 5: Convert Back to Binary

```bash
# Create directory for merged binary coverage
mkdir -p coverage-merged

# Convert merged text back to binary
go tool covdata convert -i=merged.txt -o=$(pwd)/coverage-merged -covermode=set

# Verify the binary coverage
go tool covdata func -i=$(pwd)/coverage-merged
```

## Using Binary Coverage in CI/CD

Here's how to integrate this into your CI/CD pipeline:

```yaml
# Example GitHub Actions workflow
- name: Run tests with binary coverage
  run: |
    mkdir -p $GOCOVERDIR
    go test -cover ./...
  env:
    GOCOVERDIR: ./coverage-bin

- name: Convert binary to text
  run: go tool covdata textfmt -i=./coverage-bin -o=coverage.txt

- name: Add synthetic coverage
  run: |
    cp synthetic.txt .
    go run merge-coverage.go -i=coverage.txt -s=synthetic.txt -o=merged.txt

- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    file: merged.txt
```

## Advanced: Adding Unusual File Types

Just as with the text format, binary coverage can include any file types:

```bash
# Add a .hehe file to synthetic.txt
echo "example.com/binary-demo/custom/foobar.hehe:1.1,42.1 25 1" >> synthetic.txt
```

After merging and converting back to binary, this unusual file will be included in your coverage reports.

## Coming Up Next

In Part 4, we'll explore advanced techniques and best practices for synthetic coverage:

- Automating synthetic coverage generation
- Handling different Go versions and tools
- Strategies for excluding generated code
- Integrating with various coverage tools
- Customizing coverage requirements per directory
- And more!

Stay tuned for practical advice on making synthetic coverage a robust part of your testing strategy.

---

*This is part 3 of a 4-part series on Synthetic Coverage in Go:*
- *Part 1: Understanding the Problem*
- *Part 2: Text Format Injection*
- *Part 3: Binary Format Manipulation (you are here)*
- *Part 4: Advanced Techniques and Best Practices*

-- blog-part4-advanced-techniques.md --
# Synthetic Go Coverage: Part 4 - Advanced Techniques and Best Practices

## Introduction

In the previous parts, we covered the basics of synthetic coverage in Go, working with both text and binary formats. In this final part, we'll explore advanced techniques, automation strategies, and best practices to make synthetic coverage a powerful tool in your development workflow.

## Automating Synthetic Coverage

Manual maintenance of synthetic coverage files can become tedious. Let's explore ways to automate this process.

### Option 1: Generate Synthetic Coverage from Code Comments

We can use special comments to mark sections of code that should be synthetically covered:

```go
// synth:cover
func GeneratedFunction() {
    // This function will be synthetically covered
}

// synth:cover:skip
func TestOnlyFunction() {
    // This function should be excluded from coverage requirements
}
```

Here's a sample program to extract these annotations:

```go
package main

import (
    "flag"
    "fmt"
    "go/ast"
    "go/parser"
    "go/token"
    "os"
    "path/filepath"
    "strings"
)

func main() {
    source := flag.String("source", ".", "Source directory to scan")
    output := flag.String("output", "synthetic.txt", "Output synthetic coverage file")
    flag.Parse()

    // Track synthetic coverage entries
    var entries []string
    module := detectModuleName(*source)

    // Walk source files
    err := filepath.Walk(*source, func(path string, info os.FileInfo, err error) error {
        if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") {
            return nil
        }

        // Skip test files
        if strings.HasSuffix(path, "_test.go") {
            return nil
        }

        // Parse the file
        fset := token.NewFileSet()
        file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
        if err != nil {
            return nil // Skip files that can't be parsed
        }

        // Process the file for synthetic coverage annotations
        relativePath, _ := filepath.Rel(*source, path)
        packagePath := filepath.Join(module, filepath.Dir(relativePath))
        fileName := filepath.Base(path)
        importPath := filepath.Join(packagePath, fileName)

        // Find functions with synth:cover comments
        for _, decl := range file.Decls {
            if fn, ok := decl.(*ast.FuncDecl); ok {
                found := false
                skip := false

                // Check comments
                if fn.Doc != nil {
                    for _, comment := range fn.Doc.List {
                        text := comment.Text
                        if strings.Contains(text, "synth:cover") {
                            found = true
                        }
                        if strings.Contains(text, "synth:cover:skip") {
                            skip = true
                        }
                    }
                }

                if found && !skip {
                    startLine := fset.Position(fn.Pos()).Line
                    endLine := fset.Position(fn.End()).Line
                    entry := fmt.Sprintf("%s:%d.1,%d.1 1 1", importPath, startLine, endLine)
                    entries = append(entries, entry)
                }
            }
        }

        return nil
    })

    if err != nil {
        fmt.Fprintf(os.Stderr, "Error walking source: %v\n", err)
        os.Exit(1)
    }

    // Write synthetic coverage file
    file, err := os.Create(*output)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
        os.Exit(1)
    }
    defer file.Close()

    for _, entry := range entries {
        fmt.Fprintln(file, entry)
    }

    fmt.Printf("Generated synthetic coverage with %d entries\n", len(entries))
}

func detectModuleName(dir string) string {
    // Try to detect the module name from go.mod
    data, err := os.ReadFile(filepath.Join(dir, "go.mod"))
    if err != nil {
        return "example.com/unknown"
    }

    lines := strings.Split(string(data), "\n")
    for _, line := range lines {
        if strings.HasPrefix(line, "module ") {
            return strings.TrimSpace(strings.TrimPrefix(line, "module"))
        }
    }

    return "example.com/unknown"
}
```

### Option 2: Pattern-Based Generation

Another approach is to identify files that should be synthetically covered based on patterns:

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "path/filepath"
    "strings"
)

func main() {
    source := flag.String("source", ".", "Source directory to scan")
    output := flag.String("output", "synthetic.txt", "Output synthetic coverage file")
    patterns := flag.String("patterns", "generated/,vendor/,mock_", "Comma-separated patterns to cover")
    flag.Parse()

    // Track synthetic coverage entries
    var entries []string
    patternList := strings.Split(*patterns, ",")

    // Walk source files
    err := filepath.Walk(*source, func(path string, info os.FileInfo, err error) error {
        if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") {
            return nil
        }

        // Check if file matches any pattern
        matched := false
        for _, pattern := range patternList {
            if strings.Contains(path, pattern) {
                matched = true
                break
            }
        }

        if matched {
            // Generate synthetic coverage for the entire file
            rel, _ := filepath.Rel(*source, path)
            importPath := fmt.Sprintf("example.com/project/%s", rel)
            
            // Assume 100 statements per file (you could actually count them)
            entry := fmt.Sprintf("%s:1.1,1000.1 100 1", importPath)
            entries = append(entries, entry)
        }

        return nil
    })

    if err != nil {
        fmt.Fprintf(os.Stderr, "Error walking source: %v\n", err)
        os.Exit(1)
    }

    // Write synthetic coverage file
    file, err := os.Create(*output)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
        os.Exit(1)
    }
    defer file.Close()

    for _, entry := range entries {
        fmt.Fprintln(file, entry)
    }

    fmt.Printf("Generated synthetic coverage for %d files\n", len(entries))
}
```

## Handling Generated Files

Generated code presents a common challenge for coverage. Here's a strategy specifically for handling generated files:

### Step 1: Identify Generated Files

Use `go list` to identify generated files:

```bash
go list -f '{{range .GoFiles}}{{if (contains . "generated" "zz_" "mock_")}}{{$.ImportPath}}/{{.}}{{"\n"}}{{end}}{{end}}' ./...
```

### Step 2: Generate Synthetic Coverage for Each File

For each identified file, create synthetic coverage entries:

```go
func processSyntheticForGeneratedFile(filePath, importPath string) ([]string, error) {
    // Count lines and estimate statements
    content, err := os.ReadFile(filePath)
    if err != nil {
        return nil, err
    }
    
    lines := strings.Count(string(content), "\n")
    statements := lines / 5 // Rough estimate: 1 statement per 5 lines

    if statements < 1 {
        statements = 1
    }

    return []string{
        fmt.Sprintf("%s:1.1,%d.1 %d 1", importPath, lines, statements),
    }, nil
}
```

## Custom Coverage Requirements Per Directory

Different parts of your codebase may have different coverage needs. Let's create a system to manage this:

### Step 1: Define Coverage Requirements

Create a `.coverage-config.yml` file in your repository:

```yaml
default:
  threshold: 80%
  synthetic: false

# API code should have very high coverage
api/:
  threshold: 95%
  synthetic: false

# Generated code should be excluded via synthetic coverage
generated/:
  threshold: 0%
  synthetic: true

# Utility code can have lower coverage
util/:
  threshold: 60%
  synthetic: false

# Third-party code should be excluded
vendor/:
  threshold: 0%
  synthetic: true
```

### Step 2: Create a Tool to Process This Config

```go
package main

import (
    "flag"
    "fmt"
    "io/ioutil"
    "os"
    "path/filepath"
    "strings"

    "gopkg.in/yaml.v2"
)

type CoverageConfig struct {
    Threshold string `yaml:"threshold"`
    Synthetic bool   `yaml:"synthetic"`
}

func main() {
    configFile := flag.String("config", ".coverage-config.yml", "Coverage configuration file")
    source := flag.String("source", ".", "Source directory")
    output := flag.String("output", "synthetic.txt", "Output synthetic coverage file")
    flag.Parse()

    // Read and parse config
    data, err := ioutil.ReadFile(*configFile)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error reading config: %v\n", err)
        os.Exit(1)
    }

    config := make(map[string]CoverageConfig)
    if err := yaml.Unmarshal(data, &config); err != nil {
        fmt.Fprintf(os.Stderr, "Error parsing config: %v\n", err)
        os.Exit(1)
    }

    // Default config
    defaultConfig := config["default"]
    if defaultConfig.Threshold == "" {
        defaultConfig.Threshold = "80%"
    }

    // Generate synthetic coverage based on config
    var entries []string

    // Walk source files
    err = filepath.Walk(*source, func(path string, info os.FileInfo, err error) error {
        if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") {
            return nil
        }

        // Find matching config
        relPath, _ := filepath.Rel(*source, path)
        dirPath := filepath.Dir(relPath)
        
        // Find the most specific config that applies
        bestMatch := ""
        bestConfig := defaultConfig
        
        for pattern, cfg := range config {
            if pattern == "default" {
                continue
            }
            
            if strings.HasPrefix(dirPath, pattern) && len(pattern) > len(bestMatch) {
                bestMatch = pattern
                bestConfig = cfg
            }
        }

        // If this path should be synthetically covered
        if bestConfig.Synthetic {
            // Generate synthetic coverage
            importPath := fmt.Sprintf("example.com/project/%s", relPath)
            
            // Read file to count lines and estimate statements
            content, err := ioutil.ReadFile(path)
            if err != nil {
                return nil // Skip files we can't read
            }
            
            lines := strings.Count(string(content), "\n") + 1
            statements := lines / 5 // Rough estimate
            if statements < 1 {
                statements = 1
            }
            
            entry := fmt.Sprintf("%s:1.1,%d.1 %d 1", importPath, lines, statements)
            entries = append(entries, entry)
        }

        return nil
    })

    // Write synthetic coverage file
    file, err := os.Create(*output)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
        os.Exit(1)
    }
    defer file.Close()

    for _, entry := range entries {
        fmt.Fprintln(file, entry)
    }

    fmt.Printf("Generated synthetic coverage with %d entries\n", len(entries))
}
```

## Adding Special File Types

Go's coverage tools traditionally work with `.go` files, but synthetic coverage allows you to include any file type in your reports.

### Example: Including Template Files

```go
// Find all template files and add synthetic coverage
templateFiles, err := filepath.Glob("templates/*.tmpl")
for _, file := range templateFiles {
    relPath, _ := filepath.Rel(*source, file)
    importPath := fmt.Sprintf("example.com/project/%s", relPath)
    
    // Read to count lines
    content, _ := ioutil.ReadFile(file)
    lines := strings.Count(string(content), "\n") + 1
    
    entry := fmt.Sprintf("%s:1.1,%d.1 %d 1", importPath, lines, lines/2)
    entries = append(entries, entry)
}
```

## Working with Multi-Module Repositories

For monorepos with multiple Go modules, you need to handle module paths correctly:

```go
func detectModules(root string) (map[string]string, error) {
    modules := make(map[string]string) // path -> module
    
    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
        if err != nil || !info.IsDir() {
            return nil
        }
        
        // Check for go.mod
        modPath := filepath.Join(path, "go.mod")
        if _, err := os.Stat(modPath); err != nil {
            return nil // No go.mod here
        }
        
        // Read module name
        data, err := ioutil.ReadFile(modPath)
        if err != nil {
            return nil // Skip if can't read
        }
        
        lines := strings.Split(string(data), "\n")
        for _, line := range lines {
            if strings.HasPrefix(line, "module ") {
                moduleName := strings.TrimSpace(strings.TrimPrefix(line, "module"))
                relPath, _ := filepath.Rel(root, path)
                modules[relPath] = moduleName
                break
            }
        }
        
        // Skip subdirectories of modules
        return filepath.SkipDir
    })
    
    return modules, err
}
```

## Best Practices

Based on my experience with synthetic coverage, here are some best practices:

### 1. Document Your Approach

Add a `COVERAGE.md` file explaining your synthetic coverage strategy:

```markdown
# Coverage Strategy

This project uses synthetic coverage for certain files:

- `generated/`: Auto-generated code that doesn't need testing
- `vendor/`: Third-party code
- `mocks/`: Mock implementations for testing
- `proto/`: Generated protobuf code

## How It Works

We use a synthetic coverage tool that:
1. Runs tests with real coverage
2. Adds synthetic coverage for excluded files
3. Combines them for final reports

## Adding New Synthetic Coverage

To mark a new file or directory for synthetic coverage:
1. Add it to `.coverage-config.yml`
2. Run `go generate ./...` which includes synthetic coverage generation
```

### 2. Version Control Your Synthetic Coverage Configuration

Commit your configuration, but not necessarily the generated synthetic coverage files:

```gitignore
# .gitignore
# Commit the config but not the output
.coverage-config.yml
synthetic.txt
```

### 3. Enforce Coverage Requirements in CI

Set up CI to validate coverage including synthetic data:

```yaml
# Example GitHub Actions workflow
- name: Validate coverage
  run: |
    go test -coverprofile=raw.txt ./...
    go run tools/synthetic-coverage.go -config=.coverage-config.yml -output=synthetic.txt
    go run tools/merge-coverage.go -i=raw.txt -s=synthetic.txt -o=merged.txt
    go run tools/check-coverage.go -f=merged.txt -min=80
```

### 4. Regularly Review Synthetic Coverage

As your codebase evolves, your synthetic coverage needs may change:

```bash
# Script to list files with synthetic coverage
grep -v "^mode:" synthetic.txt | cut -d':' -f1 | sort | uniq > synthetic-files.txt
echo "Files with synthetic coverage:"
cat synthetic-files.txt
```

### 5. Be Transparent About Synthetic Coverage

When sharing coverage reports, be clear about what's synthetically covered:

```go
// Generate HTML report with synthetic coverage highlighted
func generateHTMLWithHighlight(coverageFile, syntheticFile, outputFile string) error {
    // Read synthetic coverage to identify synthetic files
    synthetic, err := readSyntheticFiles(syntheticFile)
    if err != nil {
        return err
    }
    
    // Generate standard HTML report
    cmd := exec.Command("go", "tool", "cover", "-html="+coverageFile, "-o="+outputFile)
    if err := cmd.Run(); err != nil {
        return err
    }
    
    // Post-process HTML to add markers for synthetic coverage
    // (Implementation details omitted for brevity)
    
    return nil
}
```

## Conclusion

Synthetic coverage is a powerful technique that gives you more control over your coverage metrics and reports. By following the approaches outlined in this series, you can:

1. Include/exclude specific files from coverage reports
2. Add coverage for non-existent or generated files
3. Customize coverage requirements per directory
4. Automate the process of managing synthetic coverage
5. Work with both text and binary coverage formats

Remember that the goal of test coverage is not just to reach a specific percentage, but to ensure that your important business logic is well-tested. Synthetic coverage helps you focus on testing what matters by excluding code that doesn't need conventional tests.

Thank you for following this series on synthetic coverage in Go. I hope you found it informative and practical for your projects!

---

*This concludes our 4-part series on Synthetic Coverage in Go:*
- *Part 1: Understanding the Problem*
- *Part 2: Text Format Injection*
- *Part 3: Binary Format Manipulation*
- *Part 4: Advanced Techniques and Best Practices (you are here)*

-- demo/synthetic-coverage-tool.go --
// synthetic-coverage-tool.go is a simple program to add synthetic coverage to Go coverage files
package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

var (
	inputFile    = flag.String("i", "", "Input coverage file")
	outputFile   = flag.String("o", "", "Output merged coverage file")
	syntheticFile = flag.String("s", "", "Synthetic coverage file to add")
	merge        = flag.Bool("merge", true, "Merge duplicate entries (take max count)")
	debug        = flag.Bool("debug", false, "Enable debug output")
)

// CoverageLine represents a parsed line from a coverage file
type CoverageLine struct {
	FilePath   string
	StartLine  int
	StartCol   int
	EndLine    int
	EndCol     int
	Statements int
	Count      int
	Original   string
}

func main() {
	flag.Parse()

	if *inputFile == "" || *outputFile == "" {
		fmt.Println("Error: Input (-i) and output (-o) files are required")
		flag.Usage()
		os.Exit(1)
	}

	// Read the input coverage file
	realCoverage, mode, err := readCoverageFile(*inputFile)
	if err != nil {
		fmt.Printf("Error reading input coverage: %v\n", err)
		os.Exit(1)
	}

	if *debug {
		fmt.Printf("Read %d coverage lines with mode: %s\n", len(realCoverage), mode)
	}

	// Read synthetic coverage if provided
	var syntheticCoverage []CoverageLine
	if *syntheticFile != "" {
		syntheticCoverage, _, err = readCoverageFile(*syntheticFile)
		if err != nil {
			fmt.Printf("Error reading synthetic coverage: %v\n", err)
			os.Exit(1)
		}
		if *debug {
			fmt.Printf("Read %d synthetic coverage lines\n", len(syntheticCoverage))
		}
	}

	// Merge or add the coverage
	var finalCoverage []CoverageLine
	if *merge {
		finalCoverage = mergeCoverage(realCoverage, syntheticCoverage)
	} else {
		finalCoverage = append(realCoverage, syntheticCoverage...)
	}

	// Sort the coverage lines for consistency
	sortCoverage(finalCoverage)

	// Write the output
	if err := writeCoverageFile(*outputFile, mode, finalCoverage); err != nil {
		fmt.Printf("Error writing output coverage: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully created merged coverage at %s\n", *outputFile)
}

// readCoverageFile reads a coverage file and returns the parsed coverage lines and mode
func readCoverageFile(filename string) ([]CoverageLine, string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, "", fmt.Errorf("opening file: %w", err)
	}
	defer file.Close()

	var lines []CoverageLine
	var mode string

	scanner := bufio.NewScanner(file)
	lineNo := 0
	
	for scanner.Scan() {
		lineNo++
		line := scanner.Text()

		// Handle mode line
		if strings.HasPrefix(line, "mode:") {
			mode = strings.TrimSpace(strings.TrimPrefix(line, "mode:"))
			continue
		}

		// Skip empty lines
		if line == "" {
			continue
		}

		// Parse coverage line
		coverage, err := parseCoverageLine(line)
		if err != nil {
			return nil, mode, fmt.Errorf("parsing line %d: %w", lineNo, err)
		}

		lines = append(lines, coverage)
	}

	if err := scanner.Err(); err != nil {
		return nil, mode, fmt.Errorf("scanning file: %w", err)
	}

	// Default to "set" mode if not specified
	if mode == "" {
		mode = "set"
	}

	return lines, mode, nil
}

// parseCoverageLine parses a single line of coverage data
func parseCoverageLine(line string) (CoverageLine, error) {
	// Format: file:startLine.startCol,endLine.endCol statements count
	re := regexp.MustCompile(`^(.+):(\d+)\.(\d+),(\d+)\.(\d+)\s+(\d+)\s+(\d+)$`)
	matches := re.FindStringSubmatch(line)
	if matches == nil {
		return CoverageLine{}, fmt.Errorf("invalid coverage line format: %s", line)
	}

	// Extract values
	filePath := matches[1]
	startLine := parseIntOrZero(matches[2])
	startCol := parseIntOrZero(matches[3])
	endLine := parseIntOrZero(matches[4])
	endCol := parseIntOrZero(matches[5])
	statements := parseIntOrZero(matches[6])
	count := parseIntOrZero(matches[7])

	return CoverageLine{
		FilePath:   filePath,
		StartLine:  startLine,
		StartCol:   startCol,
		EndLine:    endLine,
		EndCol:     endCol,
		Statements: statements,
		Count:      count,
		Original:   line,
	}, nil
}

// parseIntOrZero parses a string to int, returning 0 on error
func parseIntOrZero(s string) int {
	val := 0
	fmt.Sscanf(s, "%d", &val)
	return val
}

// mergeCoverage merges two sets of coverage lines, taking the maximum count for duplicates
func mergeCoverage(real, synthetic []CoverageLine) []CoverageLine {
	// Create a map to track coverage by key
	coverageMap := make(map[string]CoverageLine)

	// Process real coverage
	for _, line := range real {
		key := fmt.Sprintf("%s:%d.%d,%d.%d %d", 
			line.FilePath, line.StartLine, line.StartCol, 
			line.EndLine, line.EndCol, line.Statements)
		coverageMap[key] = line
	}

	// Process synthetic coverage
	for _, line := range synthetic {
		key := fmt.Sprintf("%s:%d.%d,%d.%d %d", 
			line.FilePath, line.StartLine, line.StartCol, 
			line.EndLine, line.EndCol, line.Statements)
			
		// If this key already exists, take the maximum count
		if existing, found := coverageMap[key]; found {
			if line.Count > existing.Count {
				existing.Count = line.Count
				coverageMap[key] = existing
			}
		} else {
			coverageMap[key] = line
		}
	}

	// Convert back to slice
	var result []CoverageLine
	for _, line := range coverageMap {
		result = append(result, line)
	}

	return result
}

// sortCoverage sorts coverage lines for consistent output
func sortCoverage(lines []CoverageLine) {
	sort.Slice(lines, func(i, j int) bool {
		// Sort by file path first
		if lines[i].FilePath != lines[j].FilePath {
			return lines[i].FilePath < lines[j].FilePath
		}
		
		// Then by start position
		if lines[i].StartLine != lines[j].StartLine {
			return lines[i].StartLine < lines[j].StartLine
		}
		
		if lines[i].StartCol != lines[j].StartCol {
			return lines[i].StartCol < lines[j].StartCol
		}
		
		// Then by end position
		if lines[i].EndLine != lines[j].EndLine {
			return lines[i].EndLine < lines[j].EndLine
		}
		
		return lines[i].EndCol < lines[j].EndCol
	})
}

// writeCoverageFile writes coverage lines to a file
func writeCoverageFile(filename, mode string, lines []CoverageLine) error {
	// Create parent directory if needed
	dir := filepath.Dir(filename)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("creating directory: %w", err)
	}

	// Create output file
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("creating file: %w", err)
	}
	defer file.Close()

	// Write mode line
	if _, err := fmt.Fprintf(file, "mode: %s\n", mode); err != nil {
		return fmt.Errorf("writing mode: %w", err)
	}

	// Write coverage lines
	for _, line := range lines {
		formatted := fmt.Sprintf("%s:%d.%d,%d.%d %d %d\n",
			line.FilePath, line.StartLine, line.StartCol,
			line.EndLine, line.EndCol, line.Statements, line.Count)
			
		if _, err := file.WriteString(formatted); err != nil {
			return fmt.Errorf("writing line: %w", err)
		}
	}

	return nil
}

-- demo/README.md --
# Synthetic Coverage Demo

This directory contains demonstrations of synthetic coverage techniques for Go.

## Simple Text Approach

The simplest approach is to manipulate the text format:

```bash
# Generate real coverage
go test -coverprofile=coverage.txt ./...

# Create synthetic coverage file
cat > synthetic.txt << EOF
example.com/myproject/generated/code.go:1.1,100.1 50 1
example.com/myproject/mocks/database.go:1.1,200.1 100 1
EOF

# Merge real and synthetic coverage
go run synthetic-coverage-tool.go -i=coverage.txt -s=synthetic.txt -o=merged.txt

# View merged coverage
go tool cover -func=merged.txt
go tool cover -html=merged.txt -o=coverage.html
```

## Example: Adding Custom File Types

You can add coverage for any file type:

```bash
# Add coverage for a .hehe file
echo "example.com/myproject/special/foobar.hehe:1.1,50.1 30 1" >> synthetic.txt
```

## Example: Excluding Generated Code

Commonly used to exclude generated code from coverage requirements:

```bash
# Find all generated files
find . -name "*.pb.go" | while read -r file; do
  rel_path=$(realpath --relative-to="$(pwd)" "$file")
  echo "example.com/myproject/$rel_path:1.1,1000.1 500 1" >> synthetic.txt
done
```

## Example: Handling Unusual Files

Coverage for templates and other non-Go files:

```bash
# Add template files to coverage
find templates -name "*.tmpl" | while read -r file; do
  lines=$(wc -l < "$file")
  rel_path=$(realpath --relative-to="$(pwd)" "$file")
  echo "example.com/myproject/$rel_path:1.1,$lines.1 $((lines/2)) 1" >> synthetic.txt
done
```

## Documentation

For more details, see the accompanying blog series:
- Part 1: Understanding the Problem
- Part 2: Text Format Injection
- Part 3: Binary Format Manipulation
- Part 4: Advanced Techniques and Best Practices