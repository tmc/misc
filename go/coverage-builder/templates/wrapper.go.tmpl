// {{.Version}}-cov is a Go version wrapper that builds {{.Version}} from source
// with coverage instrumentation enabled.
//
// Generated by Go Coverage Builder
package main

import (
	"archive/tar"
	"compress/gzip"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
)

const (
	version    = "{{.Version}}"
	installDir = ".go-coverage-builds"
)

var versionInfo = struct {
	URL      string
	Checksum string
}{
	URL:      "{{.SourceURL}}",
	Checksum: "{{.Checksum}}",
}

func main() {
	log.SetFlags(0)
	
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}
	
	root, err := goroot(version)
	if err != nil {
		log.Fatalf("%s: %v", version, err)
	}
	
	switch os.Args[1] {
	case "download":
		if err := downloadAndBuild(root, version); err != nil {
			log.Fatalf("%s: download and build failed: %v", version, err)
		}
		fmt.Printf("Successfully built %s with coverage instrumentation at %s\n", version, root)
		os.Exit(0)
		
	case "env":
		if len(os.Args) > 2 && os.Args[2] == "GOROOT" {
			fmt.Println(root)
		} else {
			runGo(root, os.Args[1:])
		}
		
	case "clean":
		if err := os.RemoveAll(root); err != nil {
			log.Fatalf("Failed to clean %s: %v", root, err)
		}
		fmt.Printf("Removed %s\n", root)
		os.Exit(0)
		
	default:
		if _, err := os.Stat(filepath.Join(root, "bin", "go")); err != nil {
			log.Fatalf("%s: not downloaded. Run '%s download' to install to %v", 
				version, os.Args[0], root)
		}
		runGo(root, os.Args[1:])
	}
}

func printUsage() {
	fmt.Fprintf(os.Stderr, ` + "`" + `Usage: %s <command> [arguments]

Commands:
  download    Download and build %s with coverage instrumentation
  env         Print Go environment information
  clean       Remove the downloaded Go build
  <go-cmd>    Run any Go command using the coverage-instrumented build

Examples:
  %s download                          # Download and build Go with coverage
  %s build -cover -o myapp myapp.go    # Build your app with coverage
  GOCOVERDIR=/tmp/cov %s run main.go   # Run with coverage collection
  %s tool covdata percent -i=/tmp/cov  # Analyze coverage data

Environment Variables:
  GOEXPERIMENT   Additional experiments to enable during build
  SKIP_CHECKSUM  Skip checksum verification if set to "1"

This wrapper installs to: ~/.go-coverage-builds/%s-coverage/
` + "`" + `, os.Args[0], version, os.Args[0], os.Args[0], os.Args[0], os.Args[0], version)
}

func goroot(version string) (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(home, installDir, version+"-coverage"), nil
}

func downloadAndBuild(root, version string) error {
	// Create directory
	if err := os.MkdirAll(root, 0755); err != nil {
		return fmt.Errorf("creating directory: %w", err)
	}
	
	// Check if already built
	gobin := filepath.Join(root, "bin", "go")
	if _, err := os.Stat(gobin); err == nil {
		log.Printf("%s already built at %s, skipping download", version, root)
		return nil
	}
	
	// Clean up any previous attempts
	log.Printf("Cleaning up...")
	os.RemoveAll(root)
	os.MkdirAll(root, 0755)
	
	srcArchive := filepath.Join(os.TempDir(), version+".src.tar.gz")
	defer os.Remove(srcArchive)
	
	// Download source
	log.Printf("Downloading %s source from %s...", version, versionInfo.URL)
	if err := downloadFile(srcArchive, versionInfo.URL); err != nil {
		return fmt.Errorf("downloading source: %w", err)
	}
	
	// Verify checksum if available and not skipped
	if versionInfo.Checksum != "" && os.Getenv("SKIP_CHECKSUM") != "1" {
		log.Printf("Verifying checksum...")
		if err := verifyChecksum(srcArchive, versionInfo.Checksum); err != nil {
			return fmt.Errorf("checksum verification failed: %w", err)
		}
		log.Printf("Checksum verified")
	} else if versionInfo.Checksum == "" {
		log.Printf("Warning: No checksum available for verification")
	}
	
	// Extract source
	log.Printf("Extracting source...")
	if err := extractTarGz(srcArchive, root); err != nil {
		return fmt.Errorf("extracting source: %w", err)
	}
	
	// Build with coverage
	srcDir := filepath.Join(root, "go", "src")
	log.Printf("Building Go with coverage instrumentation...")
	log.Printf("This may take 5-10 minutes...")
	
	makeScript := "./make.bash"
	if runtime.GOOS == "windows" {
		makeScript = "make.bat"
	}
	
	cmd := exec.Command(makeScript)
	cmd.Dir = srcDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	// Set environment for coverage build
	env := os.Environ()
	envMap := make(map[string]string)
	for _, e := range env {
		parts := strings.SplitN(e, "=", 2)
		if len(parts) == 2 {
			envMap[parts[0]] = parts[1]
		}
	}
	
	// Set GOEXPERIMENT for coverage
	experiments := []string{"coverageredesign"}
	if extra := os.Getenv("GOEXPERIMENT"); extra != "" {
		experiments = append(experiments, strings.Split(extra, ",")...)
	}
	envMap["GOEXPERIMENT"] = strings.Join(experiments, ",")
	
	// Rebuild environment
	env = env[:0]
	for k, v := range envMap {
		env = append(env, k+"="+v)
	}
	cmd.Env = env
	
	log.Printf("Building with GOEXPERIMENT=%s", envMap["GOEXPERIMENT"])
	
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("building Go: %w", err)
	}
	
	// Move built files to final location
	goDir := filepath.Join(root, "go")
	for _, dir := range []string{"bin", "pkg", "src"} {
		src := filepath.Join(goDir, dir)
		dst := filepath.Join(root, dir)
		if err := os.Rename(src, dst); err != nil {
			// Try copying if rename fails (cross-device)
			if err := copyDir(src, dst); err != nil {
				return fmt.Errorf("moving %s: %w", dir, err)
			}
			os.RemoveAll(src)
		}
	}
	
	// Clean up
	os.RemoveAll(goDir)
	
	// Save build info
	buildInfo := map[string]interface{}{
		"version":     version,
		"built_with":  "coverage",
		"experiments": envMap["GOEXPERIMENT"],
		"checksum":    versionInfo.Checksum,
		"source_url":  versionInfo.URL,
		"stable":      {{.VersionInfo.Stable}},
	}
	
	infoData, _ := json.MarshalIndent(buildInfo, "", "  ")
	os.WriteFile(filepath.Join(root, "coverage-build.json"), infoData, 0644)
	
	log.Printf("Build complete!")
	return nil
}

func downloadFile(filepath string, url string) error {
	log.Printf("Downloading from %s", url)
	
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("bad status: %s", resp.Status)
	}
	
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()
	
	// Create progress reader
	size := resp.ContentLength
	if size > 0 {
		log.Printf("Download size: %.2f MB", float64(size)/(1024*1024))
	}
	
	_, err = io.Copy(out, resp.Body)
	return err
}

func verifyChecksum(file, expectedSum string) error {
	f, err := os.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()
	
	h := sha256.New()
	if _, err := io.Copy(h, f); err != nil {
		return err
	}
	
	sum := fmt.Sprintf("%x", h.Sum(nil))
	if sum != expectedSum {
		return fmt.Errorf("got %s, want %s", sum, expectedSum)
	}
	
	return nil
}

func extractTarGz(src, dst string) error {
	r, err := os.Open(src)
	if err != nil {
		return err
	}
	defer r.Close()
	
	gz, err := gzip.NewReader(r)
	if err != nil {
		return err
	}
	defer gz.Close()
	
	tr := tar.NewReader(gz)
	extracted := 0
	
	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		
		path := filepath.Join(dst, header.Name)
		
		switch header.Typeflag {
		case tar.TypeDir:
			if err := os.MkdirAll(path, os.FileMode(header.Mode)); err != nil {
				return err
			}
		case tar.TypeReg:
			if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
				return err
			}
			
			f, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))
			if err != nil {
				return err
			}
			
			if _, err := io.Copy(f, tr); err != nil {
				f.Close()
				return err
			}
			f.Close()
			extracted++
			
			if extracted%100 == 0 {
				log.Printf("Extracted %d files...", extracted)
			}
		}
	}
	
	log.Printf("Extraction complete: %d files", extracted)
	return nil
}

func copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		
		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		
		dstPath := filepath.Join(dst, relPath)
		
		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}
		
		return copyFile(path, dstPath)
	})
}

func copyFile(src, dst string) error {
	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer in.Close()
	
	out, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer out.Close()
	
	_, err = io.Copy(out, in)
	if err != nil {
		return err
	}
	
	info, err := in.Stat()
	if err != nil {
		return err
	}
	
	return out.Chmod(info.Mode())
}

func runGo(root string, args []string) {
	gobin := filepath.Join(root, "bin", "go")
	cmd := exec.Command(gobin, args...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	// Set up environment
	newPath := filepath.Join(root, "bin")
	if p := os.Getenv("PATH"); p != "" {
		newPath += string(filepath.ListSeparator) + p
	}
	
	// Preserve existing environment but override GOROOT and PATH
	envMap := make(map[string]string)
	for _, e := range os.Environ() {
		parts := strings.SplitN(e, "=", 2)
		if len(parts) == 2 {
			envMap[parts[0]] = parts[1]
		}
	}
	
	envMap["GOROOT"] = root
	envMap["PATH"] = newPath
	
	env := make([]string, 0, len(envMap))
	for k, v := range envMap {
		env = append(env, k+"="+v)
	}
	cmd.Env = env
	
	// Handle signals
	handleSignals()
	
	if err := cmd.Run(); err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			os.Exit(exitErr.ExitCode())
		}
		os.Exit(1)
	}
	os.Exit(0)
}

func handleSignals() {
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
	go func() {
		<-sigChan
		// Let the signal propagate to the child process
	}()
}